diff --git a/J3_candidate.patch b/J3_candidate.patch
new file mode 100644
index 0000000..e69de29
diff --git a/docs/J3_IMPLEMENTATION.md b/docs/J3_IMPLEMENTATION.md
new file mode 100644
index 0000000..6e09754
--- /dev/null
+++ b/docs/J3_IMPLEMENTATION.md
@@ -0,0 +1,40 @@
+# V1a Milestone J3 - Hard Gates (Silent Observer)
+
+## Summary
+
+This milestone adds a deterministic Hard Gates evaluator that produces:
+- `allowed: bool`
+- `reason_codes: list[str]` in stable, ordered form
+
+The engine computes gate inputs each cycle and publishes them in `SnapshotDTO.gates`.
+
+## Gate Reasons (Ordered)
+
+The evaluator applies gates in this fixed order:
+
+1. `ARM_OFF` ÔÇö `controls.arm == false`
+2. `INTENT_FLAT` ÔÇö `controls.intent == "FLAT"`
+3. `SESSION_NOT_OPERATING` ÔÇö session phase is not `OPERATING`
+4. `NO_QUOTE` ÔÇö bid/ask/last missing
+5. `STALE_QUOTE` ÔÇö quote age is `None` or `> STALE_THRESHOLD_MS`
+6. `FEED_DEGRADED` ÔÇö feed is degraded (disconnected or md_mode != REALTIME)
+7. `SPREAD_TOO_WIDE` ÔÇö spread_ticks exceeds `MAX_SPREAD_TICKS` (if available)
+
+Reasons are always emitted in this order for deterministic output.
+
+## Thresholds
+
+- `STALE_THRESHOLD_MS = 2000`
+- `MAX_SPREAD_TICKS = 8`
+
+## Integration Notes
+
+- Gates are computed in `src/gates.py` and consumed by the engine.
+- The engine builds `SnapshotDTO.gates.allowed` and `SnapshotDTO.gates.reason_codes`
+  and mirrors them into `ready` / `ready_reasons` (V1a invariant).
+- UI shows `allowed`, `session`, `stale`, and `reasons` per cycle.
+
+## Tests
+
+- Unit tests validate each gate reason and verify deterministic ordering in
+  `tests/test_j3_gates.py`.
diff --git a/src/engine.py b/src/engine.py
index ace09ab..3408ba2 100644
--- a/src/engine.py
+++ b/src/engine.py
@@ -2,12 +2,26 @@
 Engine Loop - Single-writer kernel loop
 Publishes atomic snapshots at fixed frequency (10 Hz default)
 """
+import math
 import time
 import threading
 import uuid
 from typing import Optional
 
-from src.snapshot import SnapshotDTO
+from src.clock import ClockProtocol, SessionManager, SystemClock
+from src.event_queue import InboundQueue
+from src.events import AdapterErrorEvent, QuoteEvent, StatusEvent
+from src.gates import GateInputs, evaluate_hard_gates
+from src.snapshot import (
+    ControlsDTO,
+    FeedDTO,
+    GatesDTO,
+    InstrumentDTO,
+    LoopHealthDTO,
+    QuoteDTO,
+    SessionDTO,
+    SnapshotDTO,
+)
 from src.datahub import DataHub
 
 
@@ -24,13 +38,19 @@ class EngineLoop:
         datahub: DataHub,
         cycle_target_ms: int = 100,  # 10 Hz
         overrun_threshold_ms: int = 500,
+        inbound_queue: Optional[InboundQueue] = None,
+        clock: Optional[ClockProtocol] = None,
     ):
         self.datahub = datahub
         self.cycle_target_ms = cycle_target_ms
         self.overrun_threshold_ms = overrun_threshold_ms
+        self.inbound_queue = inbound_queue
+        self.clock = clock or SystemClock()
+        self.session_mgr = SessionManager(clock=self.clock)
 
         # Run identity
         self.run_id = str(uuid.uuid4())
+        self._run_start_ts_unix_ms = self.clock.now_unix_ms()
 
         # State
         self._snapshot_id = 0
@@ -41,6 +61,25 @@ class EngineLoop:
         self._intent = "FLAT"
         self._arm = False
 
+        # Feed + quote state (J2/J3)
+        self._feed_connected = False
+        self._md_mode = "NONE"
+        self._feed_status_reason_codes: list[str] = []
+        self._feed_last_status_change_mono_ns: Optional[int] = None
+
+        self._quote_bid: Optional[float] = None
+        self._quote_ask: Optional[float] = None
+        self._quote_last: Optional[float] = None
+        self._quote_bid_size: Optional[int] = None
+        self._quote_ask_size: Optional[int] = None
+        self._quote_ts_recv_unix_ms: Optional[int] = None
+        self._quote_ts_recv_mono_ns: Optional[int] = None
+        self._quote_ts_exch_unix_ms: Optional[int] = None
+
+        self._last_any_event_mono_ns: Optional[int] = None
+        self._last_quote_event_mono_ns: Optional[int] = None
+        self._quotes_received_count = 0
+
     def start(self) -> None:
         """Start the engine loop in a background thread."""
         if self._running:
@@ -65,54 +104,163 @@ class EngineLoop:
         Just publishes snapshots with monotonic IDs and loop health.
         """
         while self._running:
-            cycle_start_ns = time.perf_counter_ns()
-            cycle_start_ms = int(time.time() * 1000)
-
-            # Increment snapshot ID (monotonic)
-            self._snapshot_id += 1
-
-            # Compute loop health
-            cycle_ms = 0  # Will be computed after work
-            engine_degraded = False
-
-            # Build and publish snapshot (atomic) - J2 nested structure
-            from src.snapshot import ControlsDTO, LoopHealthDTO, GatesDTO
-
-            snapshot = SnapshotDTO(
-                schema_version="snapshot.v1",
-                run_id=self.run_id,
-                snapshot_id=self._snapshot_id,
-                cycle_count=self._snapshot_id,  # Same as snapshot_id for now
-                ts_unix_ms=cycle_start_ms,
-                ts_mono_ns=cycle_start_ns,
-                controls=ControlsDTO(
-                    intent=self._intent,
-                    arm=self._arm,
-                ),
-                loop=LoopHealthDTO(
-                    cycle_ms=cycle_ms,
-                    engine_degraded=engine_degraded,
-                    last_cycle_start_mono_ns=cycle_start_ns,
-                ),
-                gates=GatesDTO(
-                    allowed=False,  # V1a.1 Slice 1: no gates yet, always False
-                    reason_codes=["ARM_OFF", "INTENT_FLAT"],  # Placeholder
-                ),
-                ready=False,  # V1a: ready == allowed
-                ready_reasons=["ARM_OFF", "INTENT_FLAT"],
-            )
-
-            self.datahub.publish(snapshot)
-
-            # Compute cycle time and sleep
-            cycle_end_ns = time.perf_counter_ns()
-            cycle_elapsed_ms = (cycle_end_ns - cycle_start_ns) // 1_000_000
-
-            # Check for overrun
-            if cycle_elapsed_ms > self.overrun_threshold_ms:
-                engine_degraded = True
+            cycle_elapsed_ms = self._run_cycle_once()
 
             # Sleep to maintain target frequency
             sleep_ms = max(0, self.cycle_target_ms - cycle_elapsed_ms)
             if sleep_ms > 0:
                 time.sleep(sleep_ms / 1000.0)
+
+    def _run_cycle_once(self) -> int:
+        cycle_start_mono_ns = self.clock.now_mono_ns()
+        cycle_start_unix_ms = self.clock.now_unix_ms()
+
+        # Increment snapshot ID (monotonic)
+        self._snapshot_id += 1
+
+        # Drain inbound events for liveness/feed/quote
+        self._drain_inbound_events()
+
+        session_date_iso = self.session_mgr.session_date_iso()
+        in_operating = self.session_mgr.in_operating_window()
+        is_break = self.session_mgr.is_break_window()
+        session_phase = self.session_mgr.session_phase()
+
+        quote_staleness_ms = None
+        if self._quote_ts_recv_mono_ns is not None:
+            quote_staleness_ms = max(
+                0, (cycle_start_mono_ns - self._quote_ts_recv_mono_ns) // 1_000_000
+            )
+
+        spread_ticks = None
+        if (
+            self._quote_bid is not None
+            and self._quote_ask is not None
+            and self._quote_ask > self._quote_bid
+        ):
+            tick_size = InstrumentDTO().tick_size
+            spread_ticks = int(math.ceil((self._quote_ask - self._quote_bid) / tick_size))
+
+        feed_degraded = (not self._feed_connected) or (self._md_mode != "REALTIME")
+        feed_reasons = []
+        if not self._feed_connected:
+            feed_reasons.append("FEED_DISCONNECTED")
+        if self._md_mode != "REALTIME":
+            feed_reasons.append("MD_NOT_REALTIME")
+
+        gate_inputs = GateInputs(
+            arm=self._arm,
+            intent=self._intent,
+            session_phase=session_phase,
+            bid=self._quote_bid,
+            ask=self._quote_ask,
+            last=self._quote_last,
+            quote_age_ms=quote_staleness_ms,
+            feed_degraded=feed_degraded,
+            spread_ticks=spread_ticks,
+        )
+        allowed, reasons = evaluate_hard_gates(gate_inputs)
+
+        cycle_elapsed_ms = int(
+            (self.clock.now_mono_ns() - cycle_start_mono_ns) / 1_000_000
+        )
+        cycle_overrun = cycle_elapsed_ms > self.cycle_target_ms
+        engine_degraded = cycle_elapsed_ms > self.overrun_threshold_ms
+
+        snapshot = SnapshotDTO(
+            schema_version="snapshot.v1",
+            run_id=self.run_id,
+            run_start_ts_unix_ms=self._run_start_ts_unix_ms,
+            snapshot_id=self._snapshot_id,
+            cycle_count=self._snapshot_id,
+            ts_unix_ms=cycle_start_unix_ms,
+            ts_mono_ns=cycle_start_mono_ns,
+            instrument=InstrumentDTO(),
+            feed=FeedDTO(
+                connected=self._feed_connected,
+                md_mode=self._md_mode,
+                degraded=feed_degraded,
+                status_reason_codes=feed_reasons or self._feed_status_reason_codes,
+                last_status_change_mono_ns=self._feed_last_status_change_mono_ns,
+            ),
+            quote=QuoteDTO(
+                bid=self._quote_bid,
+                ask=self._quote_ask,
+                last=self._quote_last,
+                bid_size=self._quote_bid_size,
+                ask_size=self._quote_ask_size,
+                ts_recv_unix_ms=self._quote_ts_recv_unix_ms,
+                ts_recv_mono_ns=self._quote_ts_recv_mono_ns,
+                ts_exch_unix_ms=self._quote_ts_exch_unix_ms,
+                staleness_ms=quote_staleness_ms,
+                spread_ticks=spread_ticks,
+            ),
+            session=SessionDTO(
+                in_operating_window=in_operating,
+                is_break_window=is_break,
+                session_date_iso=session_date_iso,
+                session_phase=session_phase,
+            ),
+            controls=ControlsDTO(
+                intent=self._intent,
+                arm=self._arm,
+            ),
+            loop=LoopHealthDTO(
+                cycle_ms=cycle_elapsed_ms,
+                cycle_overrun=cycle_overrun,
+                engine_degraded=engine_degraded,
+                last_cycle_start_mono_ns=cycle_start_mono_ns,
+            ),
+            gates=GatesDTO(
+                allowed=allowed,
+                reason_codes=reasons,
+            ),
+            last_any_event_mono_ns=self._last_any_event_mono_ns,
+            last_quote_event_mono_ns=self._last_quote_event_mono_ns,
+            quotes_received_count=self._quotes_received_count,
+            ready=allowed,
+            ready_reasons=reasons,
+        )
+
+        self.datahub.publish(snapshot)
+        return cycle_elapsed_ms
+
+    def _drain_inbound_events(self) -> None:
+        if not self.inbound_queue:
+            return
+
+        for event in self.inbound_queue.drain():
+            self._last_any_event_mono_ns = event.ts_recv_mono_ns
+
+            if isinstance(event, QuoteEvent):
+                self._last_quote_event_mono_ns = event.ts_recv_mono_ns
+                self._quotes_received_count += 1
+                if event.bid is not None:
+                    self._quote_bid = event.bid
+                if event.ask is not None:
+                    self._quote_ask = event.ask
+                if event.last is not None:
+                    self._quote_last = event.last
+                if event.bid_size is not None:
+                    self._quote_bid_size = event.bid_size
+                if event.ask_size is not None:
+                    self._quote_ask_size = event.ask_size
+                self._quote_ts_recv_unix_ms = event.ts_recv_unix_ms
+                self._quote_ts_recv_mono_ns = event.ts_recv_mono_ns
+                self._quote_ts_exch_unix_ms = event.ts_exch_unix_ms
+            elif isinstance(event, StatusEvent):
+                prev_connected = self._feed_connected
+                prev_md_mode = self._md_mode
+                self._feed_connected = bool(event.connected)
+                self._md_mode = (
+                    event.md_mode.value
+                    if hasattr(event.md_mode, "value")
+                    else str(event.md_mode)
+                )
+                if event.reason:
+                    self._feed_status_reason_codes = [event.reason]
+                if (self._feed_connected != prev_connected) or (self._md_mode != prev_md_mode):
+                    self._feed_last_status_change_mono_ns = event.ts_recv_mono_ns
+            elif isinstance(event, AdapterErrorEvent):
+                if event.error_msg:
+                    self._feed_status_reason_codes = [event.error_msg]
diff --git a/src/gates.py b/src/gates.py
new file mode 100644
index 0000000..aee6feb
--- /dev/null
+++ b/src/gates.py
@@ -0,0 +1,63 @@
+"""
+Hard Gates evaluator for V1a (Silent Observer).
+Deterministic order and stable reason codes.
+"""
+from dataclasses import dataclass
+from typing import Optional
+
+
+STALE_THRESHOLD_MS = 2000
+MAX_SPREAD_TICKS = 8
+
+REASON_ARM_OFF = "ARM_OFF"
+REASON_INTENT_FLAT = "INTENT_FLAT"
+REASON_SESSION_NOT_OPERATING = "SESSION_NOT_OPERATING"
+REASON_NO_QUOTE = "NO_QUOTE"
+REASON_STALE_QUOTE = "STALE_QUOTE"
+REASON_FEED_DEGRADED = "FEED_DEGRADED"
+REASON_SPREAD_TOO_WIDE = "SPREAD_TOO_WIDE"
+
+
+@dataclass(frozen=True)
+class GateInputs:
+    arm: bool
+    intent: str
+    session_phase: str
+    bid: Optional[float]
+    ask: Optional[float]
+    last: Optional[float]
+    quote_age_ms: Optional[int]
+    feed_degraded: bool
+    stale_threshold_ms: int = STALE_THRESHOLD_MS
+    spread_ticks: Optional[int] = None
+    max_spread_ticks: Optional[int] = MAX_SPREAD_TICKS
+
+
+def _has_complete_quote(bid: Optional[float], ask: Optional[float], last: Optional[float]) -> bool:
+    return bid is not None and ask is not None and last is not None
+
+
+def evaluate_hard_gates(inputs: GateInputs) -> tuple[bool, list[str]]:
+    reasons: list[str] = []
+
+    if not inputs.arm:
+        reasons.append(REASON_ARM_OFF)
+    if inputs.intent == "FLAT":
+        reasons.append(REASON_INTENT_FLAT)
+    if inputs.session_phase != "OPERATING":
+        reasons.append(REASON_SESSION_NOT_OPERATING)
+    if not _has_complete_quote(inputs.bid, inputs.ask, inputs.last):
+        reasons.append(REASON_NO_QUOTE)
+    if inputs.quote_age_ms is None or inputs.quote_age_ms > inputs.stale_threshold_ms:
+        reasons.append(REASON_STALE_QUOTE)
+    if inputs.feed_degraded:
+        reasons.append(REASON_FEED_DEGRADED)
+    if (
+        inputs.spread_ticks is not None
+        and inputs.max_spread_ticks is not None
+        and inputs.spread_ticks > inputs.max_spread_ticks
+    ):
+        reasons.append(REASON_SPREAD_TOO_WIDE)
+
+    allowed = len(reasons) == 0
+    return allowed, reasons
diff --git a/src/snapshot.py b/src/snapshot.py
index 51b0cd6..649a027 100644
--- a/src/snapshot.py
+++ b/src/snapshot.py
@@ -46,6 +46,7 @@ class SessionDTO:
     in_operating_window: bool = False
     is_break_window: bool = False
     session_date_iso: str = ""
+    session_phase: str = "CLOSED"
 
 
 @dataclass(frozen=True)
diff --git a/src/ui.py b/src/ui.py
index d2e033d..ef19fe9 100644
--- a/src/ui.py
+++ b/src/ui.py
@@ -66,6 +66,14 @@ class MinimalCLI:
         if len(reasons) > 30:
             reasons = reasons[:27] + "..."
 
+        session_phase = snapshot.session.session_phase
+        staleness = (
+            f"{snapshot.quote.staleness_ms}ms"
+            if snapshot.quote.staleness_ms is not None
+            else "NA"
+        )
+        feed_state = "DEGRADED" if snapshot.feed.degraded else "OK"
+
         # Single-line status display (J2: nested fields)
         status_line = (
             f"[{snapshot.snapshot_id:05d}] "
@@ -73,6 +81,9 @@ class MinimalCLI:
             f"intent={snapshot.controls.intent:5s} | "
             f"arm={str(snapshot.controls.arm):5s} | "
             f"cycle={snapshot.loop.cycle_ms:3d}ms | "
+            f"session={session_phase:9s} | "
+            f"stale={staleness:>6s} | "
+            f"feed={feed_state:8s} | "
             f"reasons={reasons}"
         )
 
diff --git a/tests/test_j3_gates.py b/tests/test_j3_gates.py
new file mode 100644
index 0000000..11fc11b
--- /dev/null
+++ b/tests/test_j3_gates.py
@@ -0,0 +1,106 @@
+import pytest
+
+from src.gates import (
+    GateInputs,
+    evaluate_hard_gates,
+    REASON_ARM_OFF,
+    REASON_INTENT_FLAT,
+    REASON_SESSION_NOT_OPERATING,
+    REASON_NO_QUOTE,
+    REASON_STALE_QUOTE,
+    REASON_FEED_DEGRADED,
+    REASON_SPREAD_TOO_WIDE,
+    STALE_THRESHOLD_MS,
+)
+
+
+def _base_inputs() -> GateInputs:
+    return GateInputs(
+        arm=True,
+        intent="LONG",
+        session_phase="OPERATING",
+        bid=1.0,
+        ask=2.0,
+        last=1.5,
+        quote_age_ms=100,
+        feed_degraded=False,
+        spread_ticks=2,
+        max_spread_ticks=8,
+    )
+
+
+def test_gate_arm_off():
+    inputs = _base_inputs().__class__(**{**_base_inputs().__dict__, "arm": False})
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_ARM_OFF in reasons
+
+
+def test_gate_intent_flat():
+    inputs = _base_inputs().__class__(**{**_base_inputs().__dict__, "intent": "FLAT"})
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_INTENT_FLAT in reasons
+
+
+def test_gate_session_not_operating():
+    inputs = _base_inputs().__class__(**{**_base_inputs().__dict__, "session_phase": "BREAK"})
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_SESSION_NOT_OPERATING in reasons
+
+
+def test_gate_no_quote():
+    inputs = _base_inputs().__class__(**{**_base_inputs().__dict__, "bid": None})
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_NO_QUOTE in reasons
+
+
+def test_gate_stale_quote():
+    inputs = _base_inputs().__class__(
+        **{**_base_inputs().__dict__, "quote_age_ms": STALE_THRESHOLD_MS + 1}
+    )
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_STALE_QUOTE in reasons
+
+
+def test_gate_feed_degraded():
+    inputs = _base_inputs().__class__(**{**_base_inputs().__dict__, "feed_degraded": True})
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_FEED_DEGRADED in reasons
+
+
+def test_gate_spread_too_wide():
+    inputs = _base_inputs().__class__(**{**_base_inputs().__dict__, "spread_ticks": 20})
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert REASON_SPREAD_TOO_WIDE in reasons
+
+
+def test_gate_reason_ordering():
+    inputs = GateInputs(
+        arm=False,
+        intent="FLAT",
+        session_phase="CLOSED",
+        bid=None,
+        ask=None,
+        last=None,
+        quote_age_ms=None,
+        feed_degraded=True,
+        spread_ticks=20,
+        max_spread_ticks=8,
+    )
+    allowed, reasons = evaluate_hard_gates(inputs)
+    assert allowed is False
+    assert reasons == [
+        REASON_ARM_OFF,
+        REASON_INTENT_FLAT,
+        REASON_SESSION_NOT_OPERATING,
+        REASON_NO_QUOTE,
+        REASON_STALE_QUOTE,
+        REASON_FEED_DEGRADED,
+        REASON_SPREAD_TOO_WIDE,
+    ]
